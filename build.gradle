buildscript {
    repositories {
        maven {
            url "https://artifactory.skyscannertools.net/artifactory/maven"
            credentials {
                username "$SKYSCANNER_ARTIFACTORY_MAVEN_USER"
                password "$SKYSCANNER_ARTIFACTORY_MAVEN_PASSWORD"
            }
        }
    }
}


plugins {
    id 'com.gradleup.shadow' version '8.3.5'
    id 'java'
    id 'jacoco'
    id 'org.sonarqube' version '6.0.1.5171'
}

apply plugin: 'java'
apply plugin: 'maven-publish'
apply plugin: 'application'
apply plugin: 'idea'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

project.ext {
    mockitoVersion = '5.15.2'
    mshellVersion = '34.0.2'
    junitVersion = '5.11.4'
    testcontainersVersion = '1.20.2'
    errorProneAnnotationsVersion = '2.36.0'
}

if (!project.hasProperty("rmihost")) {
    ext.rmihost = "localhost"
}

application {
    mainClass = "net.skyscanner.mshelltemplate.MicroServiceApplication"
}

sourceSets {
    integration {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file("src/integration/java")
        }
        resources.srcDir file("src/integration/resources")
    }
}

idea {
    module {
        testSourceDirs += project.sourceSets.integration.java.srcDirs
        testSourceDirs += project.sourceSets.integration.resources.srcDirs
    }
}

configurations {
    integrationImplementation.extendsFrom testImplementation
    integrationRuntime.extendsFrom testImplementation
}

allprojects {
    repositories {
        mavenLocal()
        maven {
            url "https://artifactory.skyscannertools.net/artifactory/maven"
            credentials {
                username "$SKYSCANNER_ARTIFACTORY_MAVEN_USER"
                password "$SKYSCANNER_ARTIFACTORY_MAVEN_PASSWORD"
            }
        }
    }
}

dependencies {
    implementation platform("net.skyscanner.mshell:mshell-java-libs-bom:${mshellVersion}")

    // gRPC dependencies for generated code and mshell-libs integration
    implementation "net.skyscanner.mshell:mshell-java-dropwizard-core"

    // protobuf support
    implementation ("io.dropwizard.modules:dropwizard-protobuf")
    compileOnly "com.google.errorprone:error_prone_annotations:${errorProneAnnotationsVersion}"

    testImplementation "net.skyscanner.mshell:mshell-java-testing"
    testImplementation "io.dropwizard:dropwizard-testing"
    testImplementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
    testImplementation "org.mockito:mockito-core:${mockitoVersion}"
    testImplementation "org.mockito:mockito-junit-jupiter:${mockitoVersion}"


    // testImplementation "org.testcontainers:testcontainers:${testcontainersVersion}"

    implementation project(":grpc")
}

shadowJar {
    mergeServiceFiles()
    archiveBaseName = "microservice-shell-java"
    archiveClassifier = ''
    archiveVersion = ''
}

sonarqube {
    properties {
        property "sonar.projectKey", "skyscanner:mshell-template"
        property "sonar.projectName", "skyscanner/mshell-template"
        property "sonar.jacoco.reportPaths", "${project.layout.buildDirectory.getAsFile().get()}/jacoco/test.exec, ${project.layout.buildDirectory.getAsFile().get()}/jacoco/integration.exec"
        property "sonar.github.repository", "skyscanner/mshell-template"
        property "sonar.exclusions", "grpc/build/**/*" // Ensure generated gRPC protobuf files are ignored
    }
}

build.dependsOn(shadowJar)

run {
    args 'server', 'dev.yml'
}

tasks.register('integration', Test) {
    testClassesDirs = sourceSets.integration.output.classesDirs
    classpath = sourceSets.integration.runtimeClasspath
}
check.dependsOn integration
integration.mustRunAfter test

tasks.register('debug') { doLast {} }
debug.dependsOn {
    run {
        jvmArgs '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005',
                '-Dcom.sun.management.jmxremote',
                '-Dcom.sun.management.jmxremote.port=1099',
                '-Dcom.sun.management.jmxremote.rmi.port=1099',
                '-Dcom.sun.management.jmxremote.local.only=false',
                '-Dcom.sun.management.jmxremote.authenticate=false',
                '-Dcom.sun.management.jmxremote.ssl=false',
                "-Djava.rmi.server.hostname=${rmihost}"
    }
}

test {
    useJUnitPlatform()
    testLogging {
        displayGranularity 1
        showStackTraces = true
        exceptionFormat = 'full'
        events "STARTED", "PASSED", "FAILED", "SKIPPED"
    }
}

integration {
    useJUnitPlatform()
    testLogging {
        displayGranularity 1
        showStackTraces = true
        exceptionFormat = 'full'
        events "STARTED", "PASSED", "FAILED", "SKIPPED"
    }
}

jacoco {
    toolVersion = "0.8.12"
}

// Ignore generated gRPC code. Keep this aligned with the proto generated types for best results
def testReportExcludeFiles = [
        'net/skyscanner/mshelltemplate/v1/HeartbeatServiceGrpc*',
        'net/skyscanner/mshelltemplate/v1/HeartbeatProto*',
        'net/skyscanner/mshelltemplate/v1/Ping*',
        'net/skyscanner/mshelltemplate/v1/Pong*',
        'net/skyscanner/mshelltemplate/v1/*Request*',
        'net/skyscanner/mshelltemplate/v1/*Response*',
]


// SonarQube can use .exec files so don't need any other formats
jacocoTestReport {
    reports {
        xml.required = false
        csv.required = false
        html.required = true // Useful for local development
    }
    afterEvaluate {
        getClassDirectories().setFrom(classDirectories.files.collect {
            fileTree(dir: it,
                    exclude: testReportExcludeFiles
            )
        })
    }
}

jacocoTestCoverageVerification {
    afterEvaluate {
        getClassDirectories().setFrom(classDirectories.files.collect {
            fileTree(dir: it,
                    exclude: testReportExcludeFiles
            )
        })
    }
    violationRules {
        rule {
            limit {
                minimum = 0.4
            }
        }
    }
}

check.dependsOn jacocoTestCoverageVerification

// This gradle file was created before all plugins properly support duplicatesStrategy. Some internal tasks
// have the duplicatesStrategy unset. This patches them to use 'exclude' as a default.
tasks.withType(ProcessResources).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
